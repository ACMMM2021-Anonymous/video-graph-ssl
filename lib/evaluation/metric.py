from __future__ import absolute_import
from __future__ import division
from __future__ import print_function
from __future__ import unicode_literals

import torch
import numpy as np

class AverageMeter(object):
    """Computes and stores the average and current value"""
    def __init__(self):
        self.reset()

    def reset(self):
        self.val = 0
        self.avg = 0
        self.sum = 0
        self.count = 0

    def update(self, val, n=1):
        self.val = val
        self.sum += val * n
        self.count += n
        self.avg = self.sum / self.count

class MAPMetric(object):
    def __init__(self):
        self.am = AverageMeter()
        self.predictions = []
        self.targets = []

    def update(self, prediction, target):
        if target.dim() == 3:
            target = target.max(dim=1)[0]
        self.targets.append(target.max(dim=0)[0])
        prediction_video = prediction.max(dim=0)[0]
        self.predictions.append(prediction_video)

    def compute(self):
        mAP, _, ap = map(np.vstack(self.predictions), np.vstack(self.targets))
        print(ap)
        return ('mAP', mAP)

def accuracy(output, target, topk=(1,)):
    """Computes the precision@k for the specified values of k"""
    if target.dim() == 3:
        target = target.max(dim=1)[0]
    maxk = max(topk)
    batch_size = target.size(0)

    _, pred = output.topk(maxk, 1, True, True)
    pred = pred.t()
    if len(target.shape) == 1:
        # print('computing accuracy for single-label case')
        correct = pred.eq(target.view(1, -1).expand_as(pred))
    else:
        # print('computing accuracy for multi-label case')
        correct = torch.zeros(*pred.shape)
        for i in range(correct.shape[0]):
            for j in range(correct.shape[1]):
                correct[i, j] = target[j, pred[i, j]] > 0.5

    res = []
    for k in topk:
        correct_k = correct[:k].view(-1).float().sum(0, keepdim=True)
        res.append(correct_k.mul_(100.0 / batch_size))
    return res

def map(submission_array, gt_array):
    """ Returns mAP, weighted mAP, and AP array """
    m_aps = []
    n_classes = submission_array.shape[1]
    for oc_i in range(n_classes):
        sorted_idxs = np.argsort(-submission_array[:, oc_i])
        tp = gt_array[:, oc_i][sorted_idxs] == 1
        fp = np.invert(tp)
        n_pos = tp.sum()
        if n_pos < 0.1:
            m_aps.append(float('nan'))
            continue
        fp.sum()
        f_pcs = np.cumsum(fp)
        t_pcs = np.cumsum(tp)
        prec = t_pcs / (f_pcs+t_pcs).astype(float)
        avg_prec = 0
        for i in range(submission_array.shape[0]):
            if tp[i]:
                avg_prec += prec[i]
        m_aps.append(avg_prec / n_pos.astype(float))
    m_aps = np.array(m_aps)
    m_ap = np.nanmean(m_aps)
    w_ap = (m_aps * gt_array.sum(axis=0) / gt_array.sum().sum().astype(float))
    return m_ap, w_ap, m_aps